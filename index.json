[{"content":"Utoolsæœªå®æ—¶æ›´æ–°ç¯å¢ƒå˜é‡é…ç½®å¯¼è‡´å‘½ä»¤è¡Œå·¥å…·ä½¿ç”¨é”™è¯¯ èƒŒæ™¯ ä»Šå¤©åœ¨ä½¿ç”¨ utoolså·¥å…·æ‰“å¼€ powershell å®‰è£… scoop ï¼Œscoop å®‰è£…æˆåŠŸåï¼Œå¯ä»¥ä½¿ç”¨ scoop ç›¸å…³å‘½ä»¤ï¼Œé‡æ–°æ‰“å¼€ powershell åä½¿ç”¨ scoop å‘½ä»¤æ— æ³•è¯†åˆ«ã€‚\né—®é¢˜å¤ç° æ‰“å¼€utools\nä½¿ç”¨utoolsæ‰“å¼€powershell\nä½¿ç”¨powershellå®‰è£…scoop\nåœ¨powershellä½¿ç”¨scoop helpå‘½ä»¤\nå…³é—­powershellï¼Œä½¿ç”¨utoolsé‡æ–°æ‰“å¼€powershell\nåœ¨powershellä¸­ä½¿ç”¨scoop helpå‘½ä»¤\næ­¤æ—¶å‡ºç°å¦‚ä¸‹çš„é”™è¯¯ä¿¡æ¯ï¼š\n1 2 3 4 5 6 7 D : æ— æ³•å°†â€œDâ€é¡¹è¯†åˆ«ä¸º cmdletã€å‡½æ•°ã€è„šæœ¬æ–‡ä»¶æˆ–å¯è¿è¡Œç¨‹åºçš„åç§°ã€‚è¯·æ£€æŸ¥åç§°çš„æ‹¼å†™ï¼Œå¦‚æœåŒ…æ‹¬è·¯å¾„ï¼Œè¯·ç¡®ä¿è·¯å¾„æ­£ç¡®ï¼Œç„¶å å†è¯•ä¸€æ¬¡ã€‚ æ‰€åœ¨ä½ç½® è¡Œ:1 å­—ç¬¦: 1 + D + ~ + CategoryInfo : ObjectNotFound: (D:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException è§£å†³æ–¹æ³• é‡æ–°å¯åŠ¨ utools\n","permalink":"https://puffinjiang.github.io/posts/tool/utoolscannotgetnewenvfromsystem/","summary":"utoolsæ— æ³•åŠæ—¶æ›´æ–°æœ€æ–°çš„ç³»ç»Ÿç¯å¢ƒå˜é‡ï¼Œå¯¼è‡´åœ¨ä½¿ç”¨powershellç­‰å‘½ä»¤è¡Œå·¥å…·æ—¶æ— æ³•è¯»å–ç›¸åº”çš„ç¯å¢ƒå˜é‡","title":"Utools Cannot Get New Env From System"},{"content":"èƒŒæ™¯ ä»Šå¤©åœ¨æˆ‘æ›´æ–°å®Œè‹¹æœæ¨é€çš„ç³»ç»Ÿæ›´æ–°ä¹‹åï¼Œæ‰“å¼€vscodeæ—¶ï¼Œå¼¹çª—æç¤º Gitæ— æ³•ä½¿ç”¨ ä¹‹ç±»çš„ä¿¡æ¯ã€‚è®©æˆ‘ä»¥ä¸ºæ›´æ–°ä¹‹åGitè¢«åˆ é™¤äº†ï¼Œ äºæ˜¯æˆ‘ä½¿ç”¨ brew upgrade git å‘½ä»¤æƒ³çœ‹ä¸€ä¸‹ä¹‹å‰å®‰è£…è¿‡çš„Gitæ˜¯å¦è¿˜åœ¨\né—®é¢˜ ä½¿ç”¨ brew install git å‘½ä»¤æ—¶ï¼ŒæŠ¥å¦‚ä¸‹é”™è¯¯ï¼š\n1 2 3 4 5 6 7 8 9 10 11 Warning: You are using macOS 13. We do not provide support for this pre-release version. You will encounter build failures with some formulae. Please create pull requests instead of asking for help on Homebrew\u0026#39;s GitHub, Twitter or any other official channels. You are responsible for resolving any issues you experience while you are running this pre-release version. Error: No developer tools installed. Install the Command Line Tools: xcode-select --install è§£å†³æ–¹æ³• è¿è¡Œ xcode-select --install ï¼Œæ­¤å‘½ä»¤ä¼šå®‰è£…ä¼šå¸®åŠ©æˆ‘ä»¬å®‰è£… Command Line Toolsï¼Œå®‰è£…å®Œæˆåå³å¯æ­£å¸¸ä½¿ç”¨ brew å‘½ä»¤äº†ã€‚\n","permalink":"https://puffinjiang.github.io/posts/tool/upgradebrewerrorafterupdatingmacos/","summary":"Git can not used after I updated the MacOS","title":"Upgrade brew error after updating MacOS"},{"content":"Flaskç®€ä»‹ Flaskæ˜¯ä¸€ä¸ªâ€œå¾®â€ python web æ¡†æ¶ï¼Œåªå®ç°äº†æœ€åŸºæœ¬çš„åŠŸèƒ½ï¼Œç®€å•ã€çµæ´»ã€å¯æ‹“å±•æ€§å¼ºã€‚\nç®€å•ï¼šä½¿ç”¨ç®€å•ï¼Œé€šè¿‡ @app.route() è£…é¥°å™¨å³å¯é…ç½®è·¯ç”± çµæ´»ï¼šé…ç½®çµæ´»ï¼Œæ”¯æŒå¤šç§ä¸åŒç±»å‹çš„é…ç½®æ–¹å¼ã€‚å¯è‡ªå®šä¹‰ ä½¿ç”¨dictå¯¹è±¡ ä½¿ç”¨ç¯å¢ƒå˜é‡ app.config.from_envvar() ä½¿ç”¨é…ç½®æ–‡ä»¶ app.config.from_file() åŒ…æ‹¬jsonã€toml å¯æ‹“å±•æ€§å¼ºï¼šå¯è‡ªå®šä¹‰å…¶ä»–éƒ¨åˆ†çš„ç»„ä»¶ï¼Œå¦‚ flask-SQLAlchemyã€flask-session ç­‰ ä¾èµ– flaskä¾èµ–çš„æ ¸å¿ƒç»„ä»¶æœ‰2ä¸ªï¼š werkzeug å’Œ jinjaã€‚ jinja æ˜¯ä¸€ä¸ªæ¨¡ç‰ˆå¼•æ“ï¼Œè´Ÿè´£æ¨¡ç‰ˆçš„æ¸²æŸ“ï¼Œwerkzeug æ˜¯ä¸€ä¸ª WSGI å·¥å…·é›†çš„åº“\nå¯åŠ¨æµç¨‹ åœ¨Flaskçš„å®˜æ–¹æ–‡æ¡£ä¸­ç»™äº†ä¸€ä¸ª \u0026lsquo;Hello World\u0026rsquo; å¯åŠ¨æ¡ˆä¾‹ï¼Œæˆ‘ä»¬æœ¬åœ°å¯åŠ¨ä¸€ä¸‹\n1 2 3 4 5 6 7 8 9 10 from flask import Flask app = Flask(__name__) @app.route(\u0026#34;/\u0026#34;) def hello_world(): return \u0026#34;\u0026lt;p\u0026gt;Hello, World!\u0026lt;/p\u0026gt;\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: app.run(\u0026#34;127.0.0.1\u0026#34;, 5000) æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥ï¼Œå¯åŠ¨çš„æ—¶å€™é¦–å…ˆè°ƒç”¨äº† app.run() æ–¹æ³•ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Flask(Scaffold): def run( self, host: t.Optional[str] = None, port: t.Optional[int] = None, debug: t.Optional[bool] = None, load_dotenv: bool = True, **options: t.Any, ) -\u0026gt; None: # Change this into a no-op if the server is invoked from the # command line. Have a look at cli.py for more information. if os.environ.get(\u0026#34;FLASK_RUN_FROM_CLI\u0026#34;) == \u0026#34;true\u0026#34;: from .debughelpers import explain_ignored_app_run explain_ignored_app_run() return if get_load_dotenv(load_dotenv): cli.load_dotenv() # if set, let env vars override previous values if \u0026#34;FLASK_ENV\u0026#34; in os.environ: self.env = get_env() self.debug = get_debug_flag() elif \u0026#34;FLASK_DEBUG\u0026#34; in os.environ: self.debug = get_debug_flag() # debug passed to method overrides all other sources if debug is not None: self.debug = bool(debug) server_name = self.config.get(\u0026#34;SERVER_NAME\u0026#34;) sn_host = sn_port = None if server_name: sn_host, _, sn_port = server_name.partition(\u0026#34;:\u0026#34;) if not host: if sn_host: host = sn_host else: host = \u0026#34;127.0.0.1\u0026#34; if port or port == 0: port = int(port) elif sn_port: port = int(sn_port) else: port = 5000 options.setdefault(\u0026#34;use_reloader\u0026#34;, self.debug) options.setdefault(\u0026#34;use_debugger\u0026#34;, self.debug) options.setdefault(\u0026#34;threaded\u0026#34;, True) cli.show_server_banner(self.env, self.debug, self.name, False) from werkzeug.serving import run_simple try: run_simple(t.cast(str, host), port, self, **options) finally: # reset the first request information if the development server # reset normally. This makes it possible to restart the server # without reloader and that stuff from an interactive shell. self._got_first_request = False æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå‰é¢ä¸€éƒ¨åˆ†ä¸»è¦æ˜¯å¤„ç†ä¸€äº›å¯åŠ¨å‚æ•°ã€‚åœ¨å‚æ•°å¤„ç†å®Œæˆä¹‹åï¼Œè°ƒç”¨äº† werkzeug.serving ä¸­çš„ run_simple å‡½æ•°ï¼Œèƒ½çœ‹åˆ°è¿™ä¸ªå‡½æ•°ä¼ å…¥äº†ä¸€ä¸ª self å‚æ•°ï¼Œå³æˆ‘ä»¬çš„ flask applicationï¼Œæˆ‘ä»¬å†è¿›å…¥è¿™ä¸ª run_simple å½“ä¸­ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 # werkzeugç›¸å…³ä»£ç  def run_simple( hostname: str, port: int, application: \u0026#34;WSGIApplication\u0026#34;, use_reloader: bool = False, use_debugger: bool = False, use_evalex: bool = True, extra_files: t.Optional[t.Iterable[str]] = None, exclude_patterns: t.Optional[t.Iterable[str]] = None, reloader_interval: int = 1, reloader_type: str = \u0026#34;auto\u0026#34;, threaded: bool = False, processes: int = 1, request_handler: t.Optional[t.Type[WSGIRequestHandler]] = None, static_files: t.Optional[t.Dict[str, t.Union[str, t.Tuple[str, str]]]] = None, passthrough_errors: bool = False, ssl_context: t.Optional[_TSSLContextArg] = None, ) -\u0026gt; None: if not isinstance(port, int): raise TypeError(\u0026#34;port must be an integer\u0026#34;) if static_files: from .middleware.shared_data import SharedDataMiddleware # é™æ€æ–‡ä»¶çš„åŠ è½½ application = SharedDataMiddleware(application, static_files) if use_debugger: from .debug import DebuggedApplication # Debugè°ƒè¯• application = DebuggedApplication(application, evalex=use_evalex) if not is_running_from_reloader(): # å¯åŠ¨å‰ socket çš„å‡†å¤‡å’Œæ£€æŸ¥ ï¼Œä½¿ç”¨IPV4è¿˜æ˜¯IPV6ã€ç«¯å£æ˜¯å¦å ç”¨ s = prepare_socket(hostname, port) fd = s.fileno() os.environ[\u0026#34;WERKZEUG_SERVER_FD\u0026#34;] = str(fd) else: fd = int(os.environ[\u0026#34;WERKZEUG_SERVER_FD\u0026#34;]) srv = make_server( hostname, port, application, threaded, processes, request_handler, passthrough_errors, ssl_context, fd=fd, ) if not is_running_from_reloader(): srv.log_startup() if use_reloader: from ._reloader import run_with_reloader run_with_reloader( srv.serve_forever, extra_files=extra_files, exclude_patterns=exclude_patterns, interval=reloader_interval, reloader_type=reloader_type, ) else: srv.serve_forever() ä»ä¸Šé¢çš„ä»£ç æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æœ‰ä¸¤å¤„å…³é”®çš„å‡½æ•°è°ƒç”¨ï¼Œä¸€å¤„æ˜¯ make_server ï¼Œå¦å¤–ä¸€å¤„æ˜¯ serve_forever ã€‚æˆ‘ä»¬å…ˆçœ‹ make_server åšäº†ä»€ä¹ˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # werkzeugç›¸å…³ä»£ç  def make_server( host: str, port: int, app: \u0026#34;WSGIApplication\u0026#34;, threaded: bool = False, processes: int = 1, request_handler: t.Optional[t.Type[WSGIRequestHandler]] = None, passthrough_errors: bool = False, ssl_context: t.Optional[_TSSLContextArg] = None, fd: t.Optional[int] = None, ) -\u0026gt; BaseWSGIServer: if threaded and processes \u0026gt; 1: raise ValueError(\u0026#34;Cannot have a multi-thread and multi-process server.\u0026#34;) if threaded: # ThreadedWSGIServer ç»§æ‰¿äº† BaseWSGIServer return ThreadedWSGIServer( host, port, app, request_handler, passthrough_errors, ssl_context, fd=fd ) if processes \u0026gt; 1: # ForkingWSGIServer ç»§æ‰¿äº† BaseWSGIServer return ForkingWSGIServer( host, port, app, processes, request_handler, passthrough_errors, ssl_context, fd=fd, ) return BaseWSGIServer( host, port, app, request_handler, passthrough_errors, ssl_context, fd=fd ) èƒ½çœ‹åˆ°è¿™é‡Œæ˜¯è¿”å›äº†ä¸€ä¸ª BaseWSGIServer å®ä¾‹åŒ–å¯¹è±¡ã€‚BaseWSGIServer åœ¨åˆå§‹åŒ–çš„æ—¶å€™ä¸»è¦åšäº† ä¸¤ä»¶äº‹æƒ…ï¼Œä¸€æ˜¯ ç»‘å®šIPå’Œç«¯å£ä»¥åŠç›‘å¬ï¼›äºŒæ˜¯æ·»åŠ  WSGIRequestHandler è¿™ä¸ªè¯·æ±‚å¤„ç†å™¨ã€‚\næˆ‘ä»¬å†æ¥çœ‹çœ‹ serve_forever åšäº†ä»€ä¹ˆï¼š\n1 2 3 4 5 6 7 8 9 10 # werkzeugç›¸å…³ä»£ç  class BaseWSGIServer(HTTPServer): def serve_forever(self, poll_interval: float = 0.5) -\u0026gt; None: try: super().serve_forever(poll_interval=poll_interval) except KeyboardInterrupt: pass finally: self.server_close() å†æ¥è¿›ä¸€æ­¥çœ‹çœ‹çˆ¶ç±»çš„ serve_forever åšäº†ä»€ä¹ˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # werkzeugç›¸å…³ä»£ç  class BaseServer: def serve_forever(self, poll_interval=0.5): \u0026#34;\u0026#34;\u0026#34;Handle one request at a time until shutdown. Polls for shutdown every poll_interval seconds. Ignores self.timeout. If you need to do periodic tasks, do them in another thread. \u0026#34;\u0026#34;\u0026#34; self.__is_shut_down.clear() try: # XXX: Consider using another file descriptor or connecting to the # socket to wake this up instead of polling. Polling reduces our # responsiveness to a shutdown request and wastes cpu at all other # times. # I/Oå¤šè·¯å¤ç”¨é€‰æ‹©å™¨ï¼Œæœ‰pollæ—¶é€‰poll with _ServerSelector() as selector: selector.register(self, selectors.EVENT_READ) while not self.__shutdown_request: # è½®è¯¢ ready = selector.select(poll_interval) # bpo-35017: shutdown() called during select(), exit immediately. if self.__shutdown_request: break if ready: self._handle_request_noblock() self.service_actions() finally: self.__shutdown_request = False self.__is_shut_down.set() æˆ‘ä»¬å¯ä»¥çœ‹åˆ°çš„æ˜¯ç›´æ¥è·³åˆ°äº† BaseServer è¿™ä¸ªç±»ï¼Œè¿™å› ä¸º BaseWSGIServer \u0026ndash;\u0026gt; HTTPServer \u0026ndash;\u0026gt; TCPServer \u0026ndash;\u0026gt; BaseServer ä»–ä»¬ä¹‹é—´æœ‰ç»§æ‰¿å…³ç³»ã€‚æ­¤å¤„é€‰ç”¨äº† PollSelector ä½œä¸º I/Oå¤šè·¯å¤ç”¨é€‰æ‹©å™¨ï¼Œå…³äºI/Oå¤šè·¯å¤ç”¨å°±ä¸è¯¦è¯´äº†ã€‚å½“æœ‰æ´»è·ƒçš„æ–‡ä»¶æè¿°ç¬¦æ—¶ï¼Œæ‰§è¡Œ _handle_request_noblock()æ–¹æ³•ï¼Œåˆ°äº†è¿™é‡Œï¼Œæˆ‘ä»¬çš„åº”ç”¨å¯åŠ¨å¹¶å¼€å§‹ç›‘å¬ç›¸å…³çš„ç«¯å£äº†ã€‚\nè¯·æ±‚å¤„ç†è¿‡ç¨‹ åœ¨ä¸Šé¢æˆ‘ä»¬å·²ç»è¯´åˆ°äº†åº”ç”¨çš„å¯åŠ¨è¿‡ç¨‹ï¼Œæ¥ä¸‹æ¥çœ‹ä¸€çœ‹å½“æ¥æ”¶åˆ°è¯·æ±‚ä¹‹åæ˜¯æ€ä¹ˆå¤„ç†çš„ã€‚ ä¸Šé¢è¯´åˆ°ï¼Œå½“æœ‰æ´»è·ƒçš„æ–‡ä»¶æè¿°ç¬¦ä¼šæ‰§è¡Œ _handle_request_noblock() æ–¹æ³•ï¼Œæ¥çœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # werkzeugç›¸å…³ä»£ç  class BaseServer: def _handle_request_noblock(self): \u0026#34;\u0026#34;\u0026#34;Handle one request, without blocking. I assume that selector.select() has returned that the socket is readable before this function was called, so there should be no risk of blocking in get_request(). \u0026#34;\u0026#34;\u0026#34; try: request, client_address = self.get_request() except OSError: return if self.verify_request(request, client_address): try: self.process_request(request, client_address) except Exception: self.handle_error(request, client_address) self.shutdown_request(request) except: self.shutdown_request(request) raise else: self.shutdown_request(request) åœ¨è¿™æ®µä»£ç é‡Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥ï¼Œè¿™é‡Œæ˜¯è°ƒç”¨äº† process_request æ–¹æ³•å»å¤„ç†æ¥æ”¶åˆ°çš„requestï¼Œè¿™ä¸ªæ—¶å€™å°±åˆ°äº†æˆ‘ä»¬å‰é¢æåˆ°çš„ WSGIRequestHandler è¿™ä¸ªè¯·æ±‚å¤„ç†å™¨äº†ã€‚ WSGIRequestHandler æ˜¯ BaseRequestHandler çš„å­ç±»ï¼Œçœ‹çœ‹åˆå§‹åŒ–ç›¸å…³çš„ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # werkzeugç›¸å…³ä»£ç  class BaseRequestHandler: def __init__(self, request, client_address, server): self.request = request self.client_address = client_address self.server = server self.setup() try: self.handle() finally: self.finish() def setup(self): pass def handle(self): pass def finish(self): pass ä»ä¸Šé¢çš„ä»£ç ä¸­å¯ä»¥çœ‹åˆ°ï¼Œåˆå§‹åŒ–æ—¶è°ƒç”¨äº† handle æ–¹æ³•ï¼Œåœ¨ handle æ–¹æ³•é‡Œæ˜¯è°ƒç”¨äº† handle_one_request æ–¹æ³•ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹è¿™ä¸ªæ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # werkzeugç›¸å…³ä»£ç  class BaseHTTPRequestHandler(socketserver.StreamRequestHandler): def handle_one_request(self): \u0026#34;\u0026#34;\u0026#34;Handle a single HTTP request. You normally don\u0026#39;t need to override this method; see the class __doc__ string for information on how to handle specific HTTP commands such as GET and POST. \u0026#34;\u0026#34;\u0026#34; try: self.raw_requestline = self.rfile.readline(65537) if len(self.raw_requestline) \u0026gt; 65536: self.requestline = \u0026#39;\u0026#39; self.request_version = \u0026#39;\u0026#39; self.command = \u0026#39;\u0026#39; self.send_error(HTTPStatus.REQUEST_URI_TOO_LONG) return if not self.raw_requestline: self.close_connection = True return if not self.parse_request(): # An error code has been sent, just exit return mname = \u0026#39;do_\u0026#39; + self.command if not hasattr(self, mname): self.send_error( HTTPStatus.NOT_IMPLEMENTED, \u0026#34;Unsupported method (%r)\u0026#34; % self.command) return method = getattr(self, mname) method() self.wfile.flush() #actually send the response if not already done. except socket.timeout as e: #a read or a write timed out. Discard this connection self.log_error(\u0026#34;Request timed out: %r\u0026#34;, e) self.close_connection = True return å¯ä»¥çœ‹åˆ°å…³é”®çš„åœ°æ–¹æ˜¯è¿™ä¸ª method æ–¹æ³•çš„è°ƒç”¨ï¼Œè€Œè¿™ä¸ª method å…¶å®å°±æ˜¯ do_GETã€do_POST ç­‰æ–¹æ³•ã€‚é€šè¿‡ debug çœ‹åˆ°ï¼Œè¿™ä¸ªæ–¹æ³•å’Œ WSGIRequestHandler.run_wsgi ç»‘å®šäº†ï¼Œå³è°ƒç”¨äº† WSGIRequestHandler.run_wsgi æ–¹æ³•ï¼Œè¿™æ˜¯å¾ˆå…³é”®çš„ä¸€ä¸ªæ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 # werkzeugç›¸å…³ä»£ç  class WSGIRequestHandler(BaseHTTPRequestHandler): def run_wsgi(self) -\u0026gt; None: if self.headers.get(\u0026#34;Expect\u0026#34;, \u0026#34;\u0026#34;).lower().strip() == \u0026#34;100-continue\u0026#34;: self.wfile.write(b\u0026#34;HTTP/1.1 100 Continue\\r\\n\\r\\n\u0026#34;) self.environ = environ = self.make_environ() status_set: t.Optional[str] = None headers_set: t.Optional[t.List[t.Tuple[str, str]]] = None status_sent: t.Optional[str] = None headers_sent: t.Optional[t.List[t.Tuple[str, str]]] = None chunk_response: bool = False def write(data: bytes) -\u0026gt; None: nonlocal status_sent, headers_sent, chunk_response assert status_set is not None, \u0026#34;write() before start_response\u0026#34; assert headers_set is not None, \u0026#34;write() before start_response\u0026#34; if status_sent is None: status_sent = status_set headers_sent = headers_set try: code_str, msg = status_sent.split(None, 1) except ValueError: code_str, msg = status_sent, \u0026#34;\u0026#34; code = int(code_str) self.send_response(code, msg) header_keys = set() for key, value in headers_sent: self.send_header(key, value) header_keys.add(key.lower()) # Use chunked transfer encoding if there is no content # length. Do not use for 1xx and 204 responses. 304 # responses and HEAD requests are also excluded, which # is the more conservative behavior and matches other # parts of the code. # https://httpwg.org/specs/rfc7230.html#rfc.section.3.3.1 if ( not ( \u0026#34;content-length\u0026#34; in header_keys or environ[\u0026#34;REQUEST_METHOD\u0026#34;] == \u0026#34;HEAD\u0026#34; or (100 \u0026lt;= code \u0026lt; 200) or code in {204, 304} ) and self.protocol_version \u0026gt;= \u0026#34;HTTP/1.1\u0026#34; ): chunk_response = True self.send_header(\u0026#34;Transfer-Encoding\u0026#34;, \u0026#34;chunked\u0026#34;) # Always close the connection. This disables HTTP/1.1 # keep-alive connections. They aren\u0026#39;t handled well by # Python\u0026#39;s http.server because it doesn\u0026#39;t know how to # drain the stream before the next request line. self.send_header(\u0026#34;Connection\u0026#34;, \u0026#34;close\u0026#34;) self.end_headers() assert isinstance(data, bytes), \u0026#34;applications must write bytes\u0026#34; if data: if chunk_response: self.wfile.write(hex(len(data))[2:].encode()) self.wfile.write(b\u0026#34;\\r\\n\u0026#34;) self.wfile.write(data) if chunk_response: self.wfile.write(b\u0026#34;\\r\\n\u0026#34;) self.wfile.flush() def start_response(status, headers, exc_info=None): # type: ignore nonlocal status_set, headers_set if exc_info: try: if headers_sent: raise exc_info[1].with_traceback(exc_info[2]) finally: exc_info = None elif headers_set: raise AssertionError(\u0026#34;Headers already set\u0026#34;) status_set = status headers_set = headers return write def execute(app: \u0026#34;WSGIApplication\u0026#34;) -\u0026gt; None: application_iter = app(environ, start_response) try: for data in application_iter: write(data) if not headers_sent: write(b\u0026#34;\u0026#34;) if chunk_response: self.wfile.write(b\u0026#34;0\\r\\n\\r\\n\u0026#34;) finally: if hasattr(application_iter, \u0026#34;close\u0026#34;): application_iter.close() # type: ignore try: execute(self.server.app) except (ConnectionError, socket.timeout) as e: self.connection_dropped(e, environ) except Exception as e: if self.server.passthrough_errors: raise if status_sent is not None and chunk_response: self.close_connection = True try: # if we haven\u0026#39;t yet sent the headers but they are set # we roll back to be able to set them again. if status_sent is None: status_set = None headers_set = None execute(InternalServerError()) except Exception: pass from .debug.tbtools import DebugTraceback msg = DebugTraceback(e).render_traceback_text() self.server.log(\u0026#34;error\u0026#34;, f\u0026#34;Error on request:\\n{msg}\u0026#34;) è¿™æ®µä»£ç é‡Œæ˜¯ execute(self.server.app) è¿™ä¸€æ®µï¼Œè€Œè¿™ä¸ª server.app å…¶å®å°±æ˜¯æˆ‘ä»¬ä¼ è¿›æ¥çš„ flask applicationäº†ï¼Œé€šè¿‡ application_iter = app(environ, start_response) è¿™ä¸€è¡Œè°ƒç”¨äº† Flask çš„ __call__ æ–¹æ³•ã€‚ä¸Šé¢æ¶‰åŠåˆ°äº†å¾ˆå¤š werkzeug ç›¸å…³çš„ä»£ç ï¼Œç„¶ååœ¨è¿™é‡Œåˆå›åˆ°äº† flaskã€‚ æ¥çœ‹ä¸€çœ‹è¿™ä¸ªæ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # Flaskç›¸å…³ä»£ç  class Flask(Scaffold): def __call__(self, environ: dict, start_response: t.Callable) -\u0026gt; t.Any: \u0026#34;\u0026#34;\u0026#34;The WSGI server calls the Flask application object as the WSGI application. This calls :meth:`wsgi_app`, which can be wrapped to apply middleware. \u0026#34;\u0026#34;\u0026#34; return self.wsgi_app(environ, start_response) def wsgi_app(self, environ: dict, start_response: t.Callable) -\u0026gt; t.Any: # åˆ›å»ºè¯·æ±‚çš„ä¸Šä¸‹æ–‡ ctx = self.request_context(environ) error: t.Optional[BaseException] = None try: try: ctx.push() response = self.full_dispatch_request() except Exception as e: error = e response = self.handle_exception(e) except: # noqa: B001 error = sys.exc_info()[1] raise return response(environ, start_response) finally: if self.should_ignore_error(error): error = None ctx.auto_pop(error) è¿™æ®µä»£ç é¦–å…ˆæ˜¯åˆ›å»ºè¯·æ±‚çš„ä¸Šä¸‹æ–‡ï¼Œç„¶åé€šè¿‡ self.full_dispatch_request() æ–¹æ³•åˆ†å‘è¯·æ±‚ï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹ full_dispatch_request çš„å…·ä½“ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Flask(Scaffold): def full_dispatch_request(self) -\u0026gt; Response: # Run before_first_request functions if this is the thread\u0026#39;s first request. # Inlined to avoid a method call on subsequent requests. # This is deprecated, will be removed in Flask 2.3. if not self._got_first_request: with self._before_request_lock: if not self._got_first_request: for func in self.before_first_request_funcs: self.ensure_sync(func)() self._got_first_request = True try: request_started.send(self) rv = self.preprocess_request() if rv is None: rv = self.dispatch_request() except Exception as e: rv = self.handle_user_exception(e) return self.finalize_request(rv) def dispatch_request(self) -\u0026gt; ft.ResponseReturnValue: req = request_ctx.request if req.routing_exception is not None: self.raise_routing_exception(req) rule: Rule = req.url_rule # type: ignore[assignment] # if we provide automatic options for this URL and the # request came with the OPTIONS method, reply automatically if ( getattr(rule, \u0026#34;provide_automatic_options\u0026#34;, False) and req.method == \u0026#34;OPTIONS\u0026#34; ): return self.make_default_options_response() # otherwise dispatch to the handler for that endpoint view_args: t.Dict[str, t.Any] = req.view_args # type: ignore[assignment] return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args) èƒ½çœ‹çš„åˆ°è¿™é‡Œ dispatch_request åˆ†å‘è¯·æ±‚ï¼Œä½¿ç”¨ handle_user_exception å¤„ç†åˆ†å‘è¿‡ç¨‹ä¸­çš„å¼‚å¸¸å¤„ç†ã€‚åœ¨ dispatch_request å½“ä¸­ï¼Œæ ¹æ®urlè·¯å¾„ï¼Œæ‰¾åˆ°ç›¸åº”çš„æ–¹æ³•ï¼Œå¹¶è°ƒç”¨ï¼Œä»£ç ä¸º self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)ã€‚æˆ‘ä»¬å†æ¥çœ‹ä¸€çœ‹ self.finalize_request(rv) åšäº†ä»€ä¹ˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Flaskç›¸å…³ä»£ç  class Flask(Scaffold): def finalize_request( self, rv: t.Union[ResponseReturnValue, HTTPException], from_error_handler: bool = False, ) -\u0026gt; Response: response = self.make_response(rv) try: response = self.process_response(response) request_finished.send(self, response=response) except Exception: if not from_error_handler: raise self.logger.exception( \u0026#34;Request finalizing failed with an error while handling an error\u0026#34; ) return response è¿™é‡Œçš„ finalize_request() å°±æ˜¯æŠŠ view_functions è¿”å›çš„ç»“æœç»„è£…æˆ Response å¹¶è¿”å›ï¼Œåœ¨å…¶ä¸­å¤„ç†äº† statusã€headersã€session ç­‰ï¼Œåˆ°æ­¤æˆ‘ä»¬çš„è¯·æ±‚å¤„ç†å°±ç»“æŸäº†ã€‚\n","permalink":"https://puffinjiang.github.io/posts/tech/flask%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","summary":"è®°å½•ä¸€ä¸‹é˜…è¯»Flaskæºç çš„è¿‡ç¨‹","title":"Flaskæºç é˜…è¯»"},{"content":"æœ€è¿‘åœ¨ä½¿ç”¨celeryè¿™ä¸ªå¼‚æ­¥æ¡†æ¶ï¼Œåœ¨ä½¿ç”¨çš„è¿‡ç¨‹ä¸­ï¼Œå‘ç°workerè¿è¡Œä¸€æ®µæ—¶é—´åï¼Œå†…å­˜æŒç»­ä¸Šæ¶¨ï¼Œç„¶åå‘Šè­¦ åœ¨ç½‘ä¸ŠæŸ¥è¯¢ä¹‹åå‘ç°äº†Celeryæœ‰å†…å­˜æ³„æ¼çš„é—®é¢˜ï¼ŒrequestsåŒ…ä¹Ÿä¼šæœ‰å†…å­˜æ³„æ¼çš„é—®é¢˜ åœ¨ç½‘ä¸ŠæŸ¥åˆ°çš„è§£å†³æ–¹æ³•æ˜¯\nåœ¨workeræ‰§è¡ŒæŒ‡å®šæ¬¡æ•°ä»»åŠ¡åé‡å»ºæ–°è¿›ç¨‹\n1 2 # æ‰§è¡Œ32æ¬¡åè¢«å¹²æ‰ worker_max_tasks_per_child = 32 åœ¨workerå†…å­˜åˆ°è¾¾æŒ‡å®šé™åˆ¶åé‡å»ºæ–°è¿›ç¨‹\n1 2 # å†…å­˜ä½¿ç”¨é‡è¾¾åˆ° 12m åè¢«å¹²æ‰ worker_max_memory_per_child = 12000 # 12m ","permalink":"https://puffinjiang.github.io/posts/tech/celery%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%A7%A3%E5%86%B3/","summary":"è®°ä¸€æ¬¡Celeryå†…å­˜æ³„æ¼çš„é—®é¢˜è§£å†³","title":"Celeryå†…å­˜æ³„æ¼è§£å†³"},{"content":"","permalink":"https://puffinjiang.github.io/links/","summary":"","title":"ğŸ¤å‹é“¾"},{"content":"è¿æ¥ ä½¿ç”¨ psql è¿œç¨‹è¿æ¥ ä½¿ç”¨uriæ–¹å¼ 1 psql postgres://username:password@host:port/dbname ä½¿ç”¨æ™®é€šçš„å‚æ•°æ–¹å¼ 1 psql -U username -h hostname -p port -d dbname æŸ¥è¯¢ åˆ—å‡ºæ‰€æœ‰çš„æ•°æ®åº“å 1 SELECT datname FROM pg_database; æ•°æ®åº“åˆ›å»ºæ“ä½œ åˆ›å»ºç”¨æˆ·åå’Œå¯†ç  1 create user username with encrypted password \u0026#39;password\u0026#39;; åˆ›å»ºæ–°çš„æ•°æ®åº“ 1 create database dbname ; æ•°æ®åº“æˆæƒæ“ä½œ 1 2 -- å°†æ•°æ®åº“ dbname æˆæƒç»™ç”¨æˆ· username grant all privileges on database dbname to username; å¤‡ä»½å’Œæ¢å¤ è¡¨å¤‡ä»½ 1 CREATE TABLE new_table AS SELECT * FROM public.old_table; è¡¨æ•°æ®åˆ é™¤ TRUNCATE å‘½ä»¤ï¼ˆå…¨è¡¨æ•°æ®åˆ é™¤ï¼‰\n1 TRUNCATE TABLE public.new_table; DELETE å‘½ä»¤\n1 DELETE FROM TABLE WHERE id = 1; ","permalink":"https://puffinjiang.github.io/posts/tool/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","summary":"è®°å½•ä¸€äº›å¸¸ç”¨çš„PostgreSQLæ•°æ®åº“æ“ä½œå‘½ä»¤","title":"PostgreSQLæ•°æ®åº“å¸¸ç”¨æ“ä½œ"},{"content":"å‰ç½®æ¡ä»¶ windowsç³»ç»Ÿã€githubè®¾ç½®éšç§é‚®ç®±\nä½¿ç”¨Githubç»™çš„é‚®ç®±æ›¿æ¢äº†åŸæœ‰çš„é‚®ç®±ï¼Œå‘½ä»¤å¦‚ä¸‹ï¼š\n1 2 git config --global user.name \u0026#34;xxx\u0026#34; git config --global user.email \u0026#34;xxx\u0026#34; ç”¨æ—§çš„é‚®ç®±è¿›è¡Œäº†commit\nè¿‡ç¨‹ åœ¨æ›¿æ¢ä¸ºæ–°çš„é‚®ç®±ä¹‹åä½¿ç”¨ git push å‘½ä»¤æäº¤ä»£ç è¢«æ‹’ç»ï¼Œè¿”å›ä»¥ä¸‹æç¤ºï¼š\n1 2 3 4 Can\u0026#39;t finish GitHub sharing process Successfully created project \u0026#39;xxx\u0026#39; on GitHub, but initial push failed: remote: error: GH007: Your push would publish a private email address. failed to push some refs to \u0026#39;xxx\u0026#39; ä½¿ç”¨ git config --list æŸ¥çœ‹é‚®ç®±æ˜¯å¦æ­£ç¡®\n1 2 user.name=xxx user.email=xxx å‘ç°æ²¡æœ‰é—®é¢˜ï¼Œå’Œä¿®æ”¹åçš„é‚®ç®±ä¸€ç›´\nç»è¿‡å›æº¯ä¹‹åï¼Œå‘ç°åœ¨ä¿®æ”¹é‚®ç®±ä¹‹å‰ï¼Œä½¿ç”¨åŸæ¥çš„é‚®ç®±è¿›è¡Œäº† commitï¼Œä½†æ˜¯æ²¡æœ‰ pushã€‚å› æ­¤commitçš„å†…å®¹ç”¨çš„è¿˜æ˜¯åŸæ¥çš„é‚®ç®±ï¼Œå¯¼è‡´pushæ—¶æŠ¥é”™\nè§£å†³æ–¹æ³• ä½¿ç”¨ git reset å‘½ä»¤å›é€€ç‰ˆæœ¬åˆ° commit ä¹‹å‰ é‡æ–° commit å’Œ pushï¼Œpush æˆåŠŸ ","permalink":"https://puffinjiang.github.io/posts/tool/git%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E5%A4%B1%E8%B4%A5/","summary":"åœ¨ä½¿ç”¨ git pushæ—¶æŠ¥ remote: error: GH007: Your push would publish a private email address.","title":"Gitæ¨é€ä»£ç å¤±è´¥"},{"content":"ğŸ‘¨â€ğŸ’» èŒä¸š ç¨‹åºå‘˜\nå¼€å‘è¯­è¨€ Python Java æ•°æ®åº“ Mysql PostgreSQL Redis MongoDB DevOps Jenkins Docker Docker-compose â›¹ å…´è¶£çˆ±å¥½ è¿åŠ¨ï¼šè¶³çƒã€ç¾½æ¯›çƒã€ç¯®çƒç­‰ é˜…è¯»ï¼šæŠ€æœ¯ä¹¦ç±ã€å°è¯´ç­‰ åŠ¨æ¼«ï¼šã€Šå‡¡äººä¿®ä»™ä¼ ã€‹ã€ã€ŠæŸç§‘å­¦çš„è¶…ç”µç£ç‚®ã€‹ç­‰ æ¸¸æˆï¼šCSGO ğŸ“¬ è”ç³»æˆ‘å‘€","permalink":"https://puffinjiang.github.io/about/","summary":"","title":"ğŸ™‹ğŸ»â€â™‚ï¸å…³äºæˆ‘"}]